isset();
    判断该变量是否存在,或该变量是否有数据值,存在或有数据值,就是true,否则就是false;
unset();
    将此变量的原有变量值地址删除,此变量将不指向任何数据了,此时用isset()判断的结果就是false;
    该数据没有任何变量指向他,就会被回收;
empty();
    判断变量的内容是否为空(不是null的空,而是没有内容),基本上,是一些硬性规定,如下数据都是空的:
    0,"","0",false,null,array()空数组也是空
    如果一个变量内容是空的.empty()返回结果是true,否则false
变量命名规则:
    基本规则:
        1:以字母或下划线开头
        2:字母数字下划线任意结尾
    行业规则:
        1:骆驼命名法:首单词小写,其后单词首字母大写
        2:帕斯卡命名法:每个单词首字母大写
        3:下划线分割法:每个单词小写,且用下划线分开
 变量的传值方式:
      1:值传递
      2:引用传递
 值传递:
       将变量1取出来(变量1中的值还在),然后再用该值给变量2赋值,相当于复制一份;
        1:此时两个变量值相等;
        2:这两个变量又是互相独立的,互不影响;
 引用传递:
        php中,只有一种语法形式可以实现变量的引用传值方式:&符号
        举例:
            $m1 =1;
            $m2 = &$m1;
        就是将地址值复制给变量2;
            1:此时仍然有了两个变量,但是只有一个数据,两个变量都共同指向该数据空间.
            2:对其中任何一个变量的操作,其实都是在操作数据值;
案例说明:见DomeDay1.php

可变变量:
    个人理解: $q1="abc"; $abc=20; echo $$q1;两个$符号,相当于取$q1的值,$q1的值是abc,所以$$q1===$abc;
预定义变量:
    预先定义好的变量;
    主要有:
        $_GET,$_POST,$_REQUEST,$_SERVER,$_GLOBALS
        1.均是数组
        2.系统定义与维护--即我们不应该给其赋值会销毁值,只应该去使用
        3.具有超全作用域--哪里都可以使用.
        4.不同情形下可能具有不同的值
    $_POST
        含义:用户通过表单以POST方式(method="post")提交的时候所提交的数据,称为POST数据;
    $_GET
     	用户通过get方式(有5种get方式)提交的数据
     	形式1:
     		<form  action="目标文件.php" method="get">
				<input type="text"  name="data1" />
				<input type="text"  name="data2" />
				<input type="submit" value="提交" />
			</form>
		形式2:
			<a href="目标文件.php"?data1=5&data2=CCTV&age=18">链接文字</a>
		形式3:
			<script>
				location.href = “目标文件.php？data1=5&data2=cctv&age=18”;
			</script>
		形式4:
			<script>
				location.assign( “目标文件.php？data1=5&data2=cctv&age=18”);
			</script>
		形式5:
			<?php
				//语法形式： header(“location: 目标网页地址”);
				header(“location: 目标文件.php？data1=5&data2=cctv&age=18”);
			?>
	$_REQUEST:
		一句话,他是$_GET变量和$_POST变量的"合集";同时存储了这两中数据

	如何同时具有get和post数据呢?
		只有一个方式:
			<form action="目标文件.php?data1=5&data2=cctv&age=18" method="post">
				<input type=”text”  name=”n1” />
				<input type=”text”  name=”n1” />
				<input  type=”submit”  value=”提交” />
			</form>
		当post数据和get数据的数据项名称相同时（其实我们反对这么做），默认是post数据覆盖了get数据。

		不过这个状况同样可以在php.ini中设置：
			搜索关键字request_order="GP" :就是GET和POST,后者覆盖前者
		修改为:
			PG: 此时就是GET数据覆盖POST数据
	$_SERVER
		含义:
			浏览网页的过程中的浏览器端的一些信息或服务器端的一些信息.
		大约30个左右的信息,我们只要知道其中5个左右
			$_SERVER['REMOTE_ADDR']:获取访问者IP地址
			$_SERVER['SERVER_ADDR']:获取服务器所在的IP地址
			$_SERVER['SERVER_NAME']:获取服务器的名字,其实就是站点设置中的servername
			$_SERVER['DOCUMENT_ROOT']:获取站点的正式物理地址,其实就是站点设置中documentroot
			$_SERVER['PHP_SELF']:获取当前网页地址(不含域名部分)
			$_SERVER['SCRIPT_FILENAME']:获取当前网页地址物理路径
			$_SERVER['QUERY_STRING']:获取当前网页地址中所有get数据(就是?好后面部分),但只是一个整体的字符创而已
	$GLOBALS
		是一个重复性数据,她里面存储了我们自己定义的所有"全局变量".
		例如:
			$s1=10;
			echo $s1;	//10
			echo $GLOBALS['v1'];	//1
		这个变量主要是用于在局部范围不可以使用全局变量的时候,有需要该全局变量的值,那么就可以使用它了,

	常量的定义:
		1.define("常量名",3.14);
		2.const 常量名 = 常量值;
	常量的取值:
		1.echo "值:".PI;
		2.constant("常量名")函数取值;
	变量与常量区别:
		定义形式不同:
		使用形式不同:常量无需$符号
		可变程度不同:常量的值不可以改变,常量也不可以销毁
		作用范围不同:常量具有超全局作用域(函数内外都可以直接使用);
		可用类型不同:常量只能存储标量类型(整数,浮点数,字符串,布尔)
	判断常量是否存在
		使用defined()函数:
			存在返回true,否则false
	使用未定义常量与变量:
		当使用未定义的常量时,系统会直接将该常量当做有值的常量去使用,并且其值就是该常量名--虽然也会报错
	
	预定义常量
		就是系统中预先定义好的常量,大约几百个
			可参考php手册
	魔术常量
		只是常量的形式.但没有常量"恒常"的含义,其值其实会变化,只有很少的几个
			__FILE__		:代表当前网页文件的完整物理路径
			__DIR__			:代表当前网页文件所在的文件夹
			__LINE__		:代表当前这个常量名所在的”行号”
-------------------------------------------------
	数据类型
		整数类型:int,integer
		浮点数类型:float,double,red
		字符串类型:string
		布尔类型:bool,boolean
	符合类型
		数组:array
		对象:object
	特殊类型
		空类型: null
		资源类型:resource
	整数类型
		4种写法
			1.$n1 =123;	//10进制数字写法
			2.$n2 =0123;	//8进制数字写法,实际n2中存储的数字比123小
			3.n3 =0x123;	//16进制数字写法,实际n3中存储的数字比123大
			4.$n4 =0b1010;	//2进制写法(目前不学)
	进制转换问题
		bin:2进制
		oct:8进制
		dec:10进制
		hex:16进制
	进制转换分两种情况
		1.10进制转换为其他3种进制:decbin(),decorct(),dechex();
		2.其他3种进制,转换为10进制
	进制转换的系统函数--必须会用
		进制转换分两种情况
			1.10进制转换为其他3种进制:
				decbin(一个10进制数字):结果返回的是该数字的2进制数字形式字符串!!
				decoct(一个10进制数字):结果返回的是该数字的8进制数字形式字符串!!
				dechecx(一个10进制数字):结果返回的是该数字的16进制数字形式的字符串！！
			2.其他3种进制,转换为10进制:
				bindec(一个2进制数字字符串)：	结果返回的是该2进制数字字符串对应的10进制数字！！！
				octdec(一个8进制数字字符串)：	结果返回的是该8进制数字字符串对应的10进制数字！！！
				hexdec(一个16进制数字字符串)：	结果返回的是该16进制数字字符串对应的10进制数字！！！
			对于输入的字符串中的字符，如果不是对应进制的数字，会被忽略。
-----------------------------------------------
	进制转换的人工计算——了解其原理
		10进制转换为2进制：
			做法：除2取余倒着写出所有余数，就是对应的2进制数字形式；
			详细解释：将一个10进制数字除以2，得到商和余数，如果商还大于等于2，则继续除以2，继续得到商和余数，以此类推，直到商为0为止，然后将前面的所有余数按倒序写出来就是对应的2进制数字。
		10进制转换为8进制：
			做法：除8取余倒着写出所有余数，就是对应的8进制数字形式；
			详细解释：将一个10进制数字除以8，得到商和余数，如果商还大于等于8，则继续除以8，继续得到商和余数，以此类推，直到商为0为止，然后将前面的所有余数按倒序写出来就是对应的8进制数字。
		10进制转换为16进制：
			做法：除16取余倒着写出所有余数，就是对应的16进制数字形式；
			详细解释：将一个10进制数字除以16，得到商和余数，如果商还大于等于16，则继续除以16，继续得到商和余数，以此类推，直到商为0为止，然后将前面的所有余数按倒序写出来就是对应的16进制数字。

		其他进制转换为10进制的做法：

			先看一种对数字大小和“数字权值”的理解：
			对一个10进制数字： 1234，可以这样去理解它的大小：
				1234 = 1*103 + 2*102 + 3*101 + 4*100  = 1000 + 200 + 30 + 4;		(任何数的0次方都是1）
				这里，我们对103 ,  102,   101,  100  等等，称为“权值”；每个位的权值是不同的。
				对于10进制，每个位上的权值，就是10 的 n次方；
				对于8进制，每个位上的权值，就是8的 n次方；
				对于16进制，每个位上的权值，就是16 的 n次方；
				对于2进制，每个位上的权值，就是2 的 n次方；

		8进制转换10进制：
			将8进制数字的每个位上的数字乘以其对应位上的权值，然后相加之后的结果。
			举例：有一个8进制数字123，则其实际大小为：
				1 * 82  +  2 * 81 +  3 * 80  =  64 + 16 + 3 = 83;

		16进制转换10进制：
			将16进制数字的每个位上的数字乘以其对应位上的权值，然后相加之后的结果。
			举例：有一个16进制数字123，则其实际大小为：
			1 * 162  +  2 * 161 +  3 * 160  =  256 + 32 + 3 = 291;

		2进制转换10进制：
			将2进制数字的每个位上的数字乘以其对应位上的权值，然后相加之后的结果。
			举例：有一个2进制数字101011，则其实际大小为：
			1 * 25  +  0 * 24  +  1 * 23  +  0 * 22  +  1 * 21  +  1 * 20=  32 + 0 + 8 + 0 + 2 + 1 = 43;
-------------------------------------------------
		浮点................


	










